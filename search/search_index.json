{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ImportSpy","text":"<p>Context\u2011aware import validation for Python modules</p> <p>ImportSpy is an open\u2011source Python library that brings structural and environmental awareness to Python\u2019s import system. It introduces a new concept: the import contract \u2014 a versioned, declarative <code>.yml</code> file that describes exactly how and where a module is allowed to be imported.</p> <p>This enables predictable, secure, and modular Python codebases, especially in complex or regulated environments.</p>"},{"location":"#what-is-an-import-contract","title":"What is an Import Contract?","text":"<p>An import contract defines what a module expects from:</p> <ul> <li>The importing environment: operating system, CPU architecture, Python version, interpreter type</li> <li>Its internal structure: functions, classes, methods, arguments, annotations, variables</li> <li>Optional runtime conditions: environment variables, base classes, or structural patterns</li> </ul> <p>If the context does not meet the declared conditions, ImportSpy blocks the import and raises a structured, human-readable error \u2014 before any runtime logic is executed.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Declarative, YAML-based import contracts  </li> <li>Embedded and CLI validation modes  </li> <li>Structural enforcement: functions, classes, variables, method signatures  </li> <li>Runtime checks: OS, architecture, Python version, interpreter  </li> <li>Contract-driven plugin validation and safe extensibility  </li> <li>CI/CD\u2011friendly error reporting  </li> <li>Seamless integration with DevSecOps pipelines</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>ImportSpy is designed for:</p> <ul> <li>Plugin frameworks with strict interface enforcement  </li> <li>Runtime protection against unsupported environments  </li> <li>Early validation in CI/CD and regulated deployments  </li> <li>Defensive boundaries between internal components  </li> <li>Automated structural checks during deployment</li> </ul>"},{"location":"#example-embedded-mode","title":"Example: Embedded Mode","text":"<pre><code>from importspy import Spy\n\ncaller = Spy().importspy(filepath=\"contracts/spymodel.yml\")\ncaller.MyPlugin().run()\n</code></pre>"},{"location":"#example-cli-mode","title":"Example: CLI Mode","text":"<pre><code>importspy src/mymodule.py -s contracts/spymodel.yml --log-level DEBUG\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<p>ImportSpy is built around:</p> <ul> <li><code>SpyModel</code>: defines expected structure and runtime environment  </li> <li><code>Spy</code>: the engine that validates real vs declared conditions  </li> <li>Violation system: structured, human\u2011readable error reporting</li> </ul>"},{"location":"#documentation-overview","title":"Documentation Overview","text":""},{"location":"#get-started","title":"Get Started","text":"<ul> <li>Quickstart </li> <li>Installation </li> <li>Overview</li> </ul>"},{"location":"#modes-of-operation","title":"Modes of Operation","text":"<ul> <li>Embedded Mode </li> <li>CLI Mode</li> </ul>"},{"location":"#import-contracts","title":"Import Contracts","text":"<ul> <li>Contract Syntax </li> <li>SpyModel Specification</li> </ul>"},{"location":"#validation-engine","title":"Validation Engine","text":"<ul> <li>Violation System </li> <li>Contract Violations</li> </ul>"},{"location":"#use-cases_1","title":"Use Cases","text":"<ul> <li>Plugin-based Architectures</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>API Docs</li> </ul>"},{"location":"#architecture-diagram","title":"Architecture Diagram","text":""},{"location":"#why-importspy","title":"Why ImportSpy?","text":"<p>Python\u2019s import mechanism is flexible, but not context-aware. ImportSpy adds a layer of governance and runtime validation, making your code more robust and secure.</p> <p>It\u2019s ideal for:</p> <ul> <li>Securing plugin boundaries  </li> <li>Enforcing internal interfaces  </li> <li>Preventing unsupported imports  </li> <li>CI/CD enforcement of import assumptions  </li> <li>Runtime compatibility in multi-environment systems</li> </ul>"},{"location":"#support-and-community","title":"Support and Community","text":"<p>If ImportSpy is useful in your infrastructure, consider:</p> <ul> <li>Starring the project on GitHub </li> <li>Becoming a GitHub Sponsor</li> </ul> <p>ImportSpy is more than a validator \u2014 it\u2019s a contract of trust between Python modules.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section documents the public Python API exposed by ImportSpy, organized by module. All components listed here are available when you install the package.</p>"},{"location":"api-reference/#importspys","title":"<code>importspy.s</code>","text":"<p>Core validation logic for ImportSpy.</p> <p>This module defines the <code>Spy</code> class, the central component responsible for dynamically  inspecting and validating Python modules against import contracts (YAML files that declare  expected structure and execution context). </p> <p>The validation can be triggered in two ways:</p> <ul> <li>Embedded validation: when the <code>Spy</code> is embedded inside a core module and validates its importer.</li> <li>External validation (CLI/pipeline): when a separate process uses <code>Spy</code> to check a module before runtime.</li> </ul> <p>Validation covers classes, attributes, functions, and environmental settings like OS, Python version, and interpreter.</p> <p>This module is typically used as the entry point for programmatic validation workflows.</p>"},{"location":"api-reference/#importspy.s.Spy","title":"<code>Spy</code>","text":"<p>Core validation engine for ImportSpy.</p> <p>The <code>Spy</code> class is responsible for loading a target module, extracting its structure, and validating it against a YAML-based import contract. This ensures that the importing module satisfies all declared structural and runtime constraints.</p> <p>It supports two modes: - Embedded mode: validates the caller of the current module - External/CLI mode: validates an explicitly provided module</p>"},{"location":"api-reference/#importspy.s.Spy--attributes","title":"Attributes:","text":"logging.Logger <p>Structured logger for validation diagnostics.</p> Parser <p>Parser used to load import contracts (defaults to YAML).</p>"},{"location":"api-reference/#importspy.s.Spy.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the Spy instance.</p> <p>Sets up a dedicated logger and the default YAML parser</p>"},{"location":"api-reference/#importspy.s.Spy.importspy","title":"<code>importspy(filepath=None, log_level=None, info_module=None)</code>","text":"<p>Main entry point for validation.</p> <p>Loads and validates a Python module against the contract defined in the given YAML file. If no module is explicitly provided, introspects the call stack to infer the caller.</p>"},{"location":"api-reference/#importspy.s.Spy.importspy--parameters","title":"Parameters:","text":"Optional[str] <p>Path to the <code>.yml</code> import contract.</p> Optional[int] <p>Log verbosity level (e.g., <code>logging.DEBUG</code>).</p> Optional[ModuleType] <p>The module to validate. If <code>None</code>, uses the importer via stack inspection.</p>"},{"location":"api-reference/#importspy.s.Spy.importspy--returns","title":"Returns:","text":"<p>ModuleType     The validated module.</p>"},{"location":"api-reference/#importspy.s.Spy.importspy--raises","title":"Raises:","text":"<p>RuntimeError     If logging setup fails.</p> <p>ValueError     If recursion is detected (e.g., a module is validating itself).</p>"},{"location":"api-reference/#importspymodels","title":"<code>importspy.models</code>","text":""},{"location":"api-reference/#importspy.models--modelspy","title":"models.py","text":"<p>Defines the structural and contextual data models used across ImportSpy. These models represent modules, variables, functions, classes, runtimes, systems, and environments involved in contract-based validation.</p> <p>This module powers both embedded validation and CLI checks, enabling ImportSpy to introspect, serialize, and enforce compatibility rules at multiple levels: from source code structure to runtime platform details.</p>"},{"location":"api-reference/#importspy.models.Argument","title":"<code>Argument</code>","text":"<p>               Bases: <code>Variable</code>, <code>BaseModel</code></p> <p>Represents a function/method argument.</p> <p>Includes: - Name - Optional type annotation - Optional default value Used to check call signatures.</p>"},{"location":"api-reference/#importspy.models.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>Variable</code></p> <p>Represents a class-level attribute.</p> <p>Extends Variable with attribute type (e.g., class or instance).</p>"},{"location":"api-reference/#importspy.models.Class","title":"<code>Class</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Python class declaration.</p> <p>Includes: - Name - Attributes (class/instance) - Methods - Superclasses (recursive)</p>"},{"location":"api-reference/#importspy.models.Environment","title":"<code>Environment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents runtime environment variables and secrets. Used for validating runtime configuration.</p>"},{"location":"api-reference/#importspy.models.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes a structured validation error.</p> <p>Includes the context, error type, message, and resolution steps. Used to serialize feedback during contract enforcement.</p>"},{"location":"api-reference/#importspy.models.Function","title":"<code>Function</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a callable entity.</p> <p>Includes: - Name - List of arguments - Optional return annotation</p>"},{"location":"api-reference/#importspy.models.Module","title":"<code>Module</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Python module.</p> <p>Includes: - Filename - Version (if extractable) - Top-level variables, functions, and classes</p>"},{"location":"api-reference/#importspy.models.Python","title":"<code>Python</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a Python runtime environment.</p> <p>Includes: - Python version - Interpreter type (e.g., CPython, PyPy) - List of loaded modules Used in validating runtime compatibility.</p>"},{"location":"api-reference/#importspy.models.Runtime","title":"<code>Runtime</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a runtime deployment context.</p> <p>Defined by CPU architecture and associated systems.</p>"},{"location":"api-reference/#importspy.models.SpyModel","title":"<code>SpyModel</code>","text":"<p>               Bases: <code>Module</code></p> <p>High-level model used by ImportSpy for validation.</p> <p>Extends the module representation with runtime metadata and platform-specific deployment constraints (architecture, OS, interpreter, etc).</p>"},{"location":"api-reference/#importspy.models.SpyModel.from_module","title":"<code>from_module(info_module)</code>  <code>classmethod</code>","text":"<p>Build a SpyModel instance by extracting structure and metadata from an actual Python module object.</p>"},{"location":"api-reference/#importspy.models.System","title":"<code>System</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a full OS environment within a deployment system.</p> <p>Includes: - OS type - Environment variables - Python runtimes Used to validate cross-platform compatibility.</p>"},{"location":"api-reference/#importspy.models.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a top-level variable in a Python module.</p> <p>Includes: - Name - Optional annotation - Optional static value Used to enforce structural consistency.</p>"},{"location":"api-reference/#importspyvalidators","title":"<code>importspy.validators</code>","text":"<p>ImportSpy Contract Validators</p> <p>This module defines structural and runtime validators for comparing expected contract definitions against observed runtime representations.</p> <p>Each validator compares a specific domain (e.g., Python version, environment variables, module structure, class layout) using ImportSpy's SpyModel structures.</p> <p>If mismatches or missing elements are detected, specialized <code>ContractViolation</code> objects raise informative <code>ValueError</code> exceptions enriched with context bundles.</p> <p>Used both in embedded runtime validation and CLI mode.</p>"},{"location":"api-reference/#importspy.validators.ClassValidator","title":"<code>ClassValidator</code>","text":"<p>Validates class structure, attributes, and methods.</p>"},{"location":"api-reference/#importspy.validators.ClassValidator.validate","title":"<code>validate(classes_1, classes_2, contract_violation)</code>","text":"<p>Recursively validate class structure and inheritance.</p> <p>Parameters:</p> Name Type Description Default <code>classes_1</code> <code>List[Class]</code> <p>Expected class definitions.</p> required <code>classes_2</code> <code>List[Class]</code> <p>Observed runtime classes.</p> required <code>contract_violation</code> <code>BaseContractViolation</code> <p>Shared context for error propagation.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>On missing class, method, or attribute mismatch.</p>"},{"location":"api-reference/#importspy.validators.FunctionValidator","title":"<code>FunctionValidator</code>","text":"<p>Validates functions, their arguments, and return annotations.</p>"},{"location":"api-reference/#importspy.validators.FunctionValidator.validate","title":"<code>validate(functions_1, functions_2, contract_violation)</code>","text":"<p>Compare function definitions across two modules or classes.</p> <p>Parameters:</p> Name Type Description Default <code>functions_1</code> <code>List[Function]</code> <p>Expected functions.</p> required <code>functions_2</code> <code>List[Function]</code> <p>Observed functions.</p> required <code>contract_violation</code> <code>BaseContractViolation</code> <p>Violation context object.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>On missing, unmatched, or misannotated functions.</p>"},{"location":"api-reference/#importspy.validators.ModuleValidator","title":"<code>ModuleValidator</code>","text":"<p>Validates modules, including structure, variables, functions, and classes.</p>"},{"location":"api-reference/#importspy.validators.ModuleValidator.validate","title":"<code>validate(modules_1, module_2, contract_violation)</code>","text":"<p>Validate module structure against expected SpyModel.</p> <p>Parameters:</p> Name Type Description Default <code>modules_1</code> <code>List[Module]</code> <p>List of expected module definitions.</p> required <code>module_2</code> <code>Module</code> <p>Observed runtime module.</p> required <code>contract_violation</code> <code>ModuleContractViolation</code> <p>Context bundle.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>On mismatch or missing module details.</p>"},{"location":"api-reference/#importspy.validators.PythonValidator","title":"<code>PythonValidator</code>","text":"<p>Validates Python version and interpreter compatibility.</p>"},{"location":"api-reference/#importspy.validators.PythonValidator.validate","title":"<code>validate(pythons_1, pythons_2, contract_violation)</code>","text":"<p>Ensure that Python version/interpreter match expectations.</p> <p>Parameters:</p> Name Type Description Default <code>pythons_1</code> <code>List[Python]</code> <p>Contract-defined expectations.</p> required <code>pythons_2</code> <code>List[Python]</code> <p>Runtime-detected Python instances.</p> required <code>contract_violation</code> <code>PythonContractViolation</code> <p>Context bundle and error factory.</p> required <p>Returns:</p> Type Description <code>None</code> <p>List[Module]: Modules associated with the matched Python.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>On missing or mismatched Python definitions.</p>"},{"location":"api-reference/#importspy.validators.RuntimeValidator","title":"<code>RuntimeValidator</code>","text":"<p>Validates architecture compatibility between runtime collections.</p>"},{"location":"api-reference/#importspy.validators.RuntimeValidator.validate","title":"<code>validate(runtimes_1, runtimes_2, contract_violation)</code>","text":"<p>Compare runtime architectures and raise if no match is found.</p> <p>Parameters:</p> Name Type Description Default <code>runtimes_1</code> <code>List[Runtime]</code> <p>Declared runtime requirements.</p> required <code>runtimes_2</code> <code>List[Runtime]</code> <p>Observed runtime environments.</p> required <code>contract_violation</code> <code>RuntimeContractViolation</code> <p>Violation reporter instance.</p> required <p>Returns:</p> Name Type Description <code>Runtime</code> <code>None</code> <p>The matching runtime, if found.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If runtimes_2 is empty or no arch matches.</p>"},{"location":"api-reference/#importspy.validators.SystemValidator","title":"<code>SystemValidator</code>","text":"<p>Validates operating system and environment compatibility.</p>"},{"location":"api-reference/#importspy.validators.SystemValidator.EnvironmentValidator","title":"<code>EnvironmentValidator</code>","text":"<p>Validates environment-level variables and configuration.</p>"},{"location":"api-reference/#importspy.validators.SystemValidator.EnvironmentValidator.validate","title":"<code>validate(environment_1, environment_2, bundle)</code>","text":"<p>Compare two environments' variable lists.</p> <p>Parameters:</p> Name Type Description Default <code>environment_1</code> <code>Environment</code> <p>Expected environment.</p> required <code>environment_2</code> <code>Environment</code> <p>Observed environment.</p> required <code>bundle</code> <code>Bundle</code> <p>Violation context and data.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>On missing or mismatched variables.</p>"},{"location":"api-reference/#importspy.validators.SystemValidator.validate","title":"<code>validate(systems_1, systems_2, contract_violation)</code>","text":"<p>Compare systems and delegate to environment validation.</p> <p>Parameters:</p> Name Type Description Default <code>systems_1</code> <code>List[System]</code> <p>Expected system definitions.</p> required <code>systems_2</code> <code>List[System]</code> <p>Runtime-observed systems.</p> required <code>contract_violation</code> <code>SystemContractViolation</code> <p>Violation context and bundle.</p> required <p>Returns:</p> Type Description <code>None</code> <p>List[Python]: Matching Python objects if validation passes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no matching OS or missing environment.</p>"},{"location":"api-reference/#importspy.validators.VariableValidator","title":"<code>VariableValidator</code>","text":"<p>Validates variables, attributes, and annotations.</p>"},{"location":"api-reference/#importspy.validators.VariableValidator.validate","title":"<code>validate(variables_1, variables_2, contract_violation)</code>","text":"<p>Validate variable existence, name, value, and annotation.</p> <p>Parameters:</p> Name Type Description Default <code>variables_1</code> <code>List[Variable]</code> <p>Expected variables.</p> required <code>variables_2</code> <code>List[Variable]</code> <p>Actual runtime variables.</p> required <code>contract_violation</code> <code>VariableContractViolation</code> <p>Violation and error builder.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>On missing or mismatched variables.</p>"},{"location":"api-reference/#importspyviolation_systems","title":"<code>importspy.violation_systems</code>","text":"<p>This module defines the hierarchy of contract violation classes used by ImportSpy.</p> <p>Each violation type corresponds to a validation context (e.g., environment, runtime, module structure), and provides structured, human-readable error messages when the importing module does not meet the contract\u2019s requirements.</p> <p>The base interface <code>ContractViolation</code> defines the common error interface, while specialized classes like <code>VariableContractViolation</code> or <code>RuntimeContractViolation</code> define formatting logic for each scope.</p> <p>Violations carry a dynamic <code>Bundle</code> object, which collects contextual metadata needed for formatting error messages and debugging failed imports.</p>"},{"location":"api-reference/#importspy.violation_systems.BaseContractViolation","title":"<code>BaseContractViolation</code>","text":"<p>               Bases: <code>ContractViolation</code></p> <p>Base implementation of a contract violation.</p> <p>Includes default implementations of error formatting methods.</p>"},{"location":"api-reference/#importspy.violation_systems.Bundle","title":"<code>Bundle</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MutableMapping</code></p> <p>Shared mutable state passed to all violation handlers.</p> <p>The bundle is a dynamic container used to inject contextual values (like module name, attribute name, or class name) into error templates.</p>"},{"location":"api-reference/#importspy.violation_systems.ContractViolation","title":"<code>ContractViolation</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base interface for all contract violations.</p> <p>Defines the core methods for rendering structured error messages, including context resolution and label generation.</p>"},{"location":"api-reference/#importspy.violation_systems.ContractViolation--properties","title":"Properties:","text":"<ul> <li><code>context</code>: Validation context (e.g., environment, class, runtime)</li> <li><code>label(spec)</code>: Retrieves the field name or reference used in error text.</li> <li><code>missing_error_handler(spec)</code>: Formats error when required entity is missing.</li> <li><code>mismatch_error_handler(expected, actual, spec)</code>: Formats error when values differ.</li> <li><code>invalid_error_handler(allowed, found, spec)</code>: Formats error when a value is invalid.</li> </ul>"},{"location":"api-reference/#importspy.violation_systems.FunctionContractViolation","title":"<code>FunctionContractViolation</code>","text":"<p>               Bases: <code>BaseContractViolation</code></p> <p>Contract violation handler for function signature mismatches.</p>"},{"location":"api-reference/#importspy.violation_systems.ModuleContractViolation","title":"<code>ModuleContractViolation</code>","text":"<p>               Bases: <code>BaseContractViolation</code></p> <p>Contract violation handler for module-level mismatches (filename, version, structure).</p>"},{"location":"api-reference/#importspy.violation_systems.PythonContractViolation","title":"<code>PythonContractViolation</code>","text":"<p>               Bases: <code>BaseContractViolation</code></p> <p>Contract violation handler for Python version and interpreter mismatches.</p>"},{"location":"api-reference/#importspy.violation_systems.RuntimeContractViolation","title":"<code>RuntimeContractViolation</code>","text":"<p>               Bases: <code>BaseContractViolation</code></p> <p>Contract violation handler for runtime architecture mismatches.</p>"},{"location":"api-reference/#importspy.violation_systems.SystemContractViolation","title":"<code>SystemContractViolation</code>","text":"<p>               Bases: <code>BaseContractViolation</code></p> <p>Contract violation handler for system-level mismatches (OS, environment variables).</p>"},{"location":"api-reference/#importspy.violation_systems.VariableContractViolation","title":"<code>VariableContractViolation</code>","text":"<p>               Bases: <code>BaseContractViolation</code></p> <p>Contract violation handler for variables (module, class, environment, etc.).</p> <p>Includes scope information to distinguish between types of variables.</p>"},{"location":"api-reference/#importspypersistences","title":"<code>importspy.persistences</code>","text":"<p>Defines interfaces and implementations for handling import contracts \u2014 external YAML files used by ImportSpy to validate the structure and runtime expectations of dynamically loaded Python modules.</p> <p>Currently, only YAML is supported, but the architecture is extensible via the <code>Parser</code> interface.</p> <p>All file I/O operations are wrapped in <code>handle_persistence_error</code>, ensuring clear error messages in case of missing, malformed, or inaccessible contract files.</p>"},{"location":"api-reference/#importspy.persistences.Parser","title":"<code>Parser</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for import contract parsers.</p> <p>Parsers are responsible for loading and saving <code>.yml</code> contract files that define a module\u2019s structural and runtime expectations. This abstraction enables future support for additional formats (e.g., JSON, TOML).</p> <p>Subclasses must implement <code>save()</code> and <code>load()</code>.</p>"},{"location":"api-reference/#importspy.persistences.Parser.load","title":"<code>load(filepath)</code>  <code>abstractmethod</code>","text":"<p>Parses a contract file and returns it as a dictionary.</p>"},{"location":"api-reference/#importspy.persistences.Parser.load--parameters","title":"Parameters:","text":"str <p>Path to the contract file on disk.</p>"},{"location":"api-reference/#importspy.persistences.Parser.load--returns","title":"Returns:","text":"<p>dict     Parsed contract data.</p>"},{"location":"api-reference/#importspy.persistences.Parser.save","title":"<code>save(data, filepath)</code>  <code>abstractmethod</code>","text":"<p>Serializes the contract (as a dictionary) and writes it to disk.</p>"},{"location":"api-reference/#importspy.persistences.Parser.save--parameters","title":"Parameters:","text":"dict <p>Dictionary containing the contract structure.</p> str <p>Target path for saving the contract (typically <code>.yml</code>).</p>"},{"location":"api-reference/#importspy.persistences.PersistenceError","title":"<code>PersistenceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when contract loading or saving fails due to I/O or syntax issues.</p> <p>This exception wraps low-level errors and provides human-readable feedback.</p>"},{"location":"api-reference/#importspy.persistences.PersistenceError.__init__","title":"<code>__init__(msg)</code>","text":"<p>Initialize the error with a descriptive message.</p>"},{"location":"api-reference/#importspy.persistences.PersistenceError.__init__--parameters","title":"Parameters:","text":"str <p>Explanation of the failure.</p>"},{"location":"api-reference/#importspy.persistences.YamlParser","title":"<code>YamlParser</code>","text":"<p>               Bases: <code>Parser</code></p> <p>YAML-based contract parser implementation.</p> <p>Uses <code>ruamel.yaml</code> to read and write <code>.yml</code> files that define import contracts. Preserves formatting, indentation, and quotes for consistent serialization.</p>"},{"location":"api-reference/#importspy.persistences.YamlParser.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the YAML parser and configures output formatting.</p>"},{"location":"api-reference/#importspy.persistences.YamlParser.load","title":"<code>load(filepath)</code>","text":"<p>Loads and parses a <code>.yml</code> contract into a Python dictionary.</p>"},{"location":"api-reference/#importspy.persistences.YamlParser.load--parameters","title":"Parameters:","text":"str <p>Path to the contract file.</p>"},{"location":"api-reference/#importspy.persistences.YamlParser.load--returns","title":"Returns:","text":"<p>dict     Parsed contract structure.</p>"},{"location":"api-reference/#importspy.persistences.YamlParser.save","title":"<code>save(data, filepath)</code>","text":"<p>Saves a contract dictionary to a <code>.yml</code> file.</p>"},{"location":"api-reference/#importspy.persistences.YamlParser.save--parameters","title":"Parameters:","text":"dict <p>Contract structure.</p> str <p>Destination file path.</p>"},{"location":"api-reference/#importspy.persistences.handle_persistence_error","title":"<code>handle_persistence_error(func)</code>","text":"<p>Decorator for wrapping parser I/O methods with user-friendly error handling.</p> <p>Catches all exceptions and raises a <code>PersistenceError</code> with a generic message. This ensures ImportSpy fails gracefully if a contract file is missing, malformed, or inaccessible.</p>"},{"location":"api-reference/#importspy.persistences.handle_persistence_error--parameters","title":"Parameters:","text":"<p>func : Callable     The I/O method to wrap.</p>"},{"location":"api-reference/#importspy.persistences.handle_persistence_error--returns","title":"Returns:","text":"<p>Callable     A wrapped version that raises <code>PersistenceError</code> on failure.</p>"},{"location":"api-reference/#importspycli","title":"<code>importspy.cli</code>","text":"<p>Command-line interface (CLI) for validating Python modules against ImportSpy contracts.</p> <p>This module defines the <code>importspy</code> CLI command, enabling local and automated validation of a Python file against a YAML-based SpyModel contract. It is designed for use in CI/CD pipelines, plugin systems, or developer workflows.</p> <p>Features: - Loads and executes the specified Python module. - Parses the YAML contract file describing expected structure and runtime conditions. - Validates that the module complies with the declared interface and environment. - Provides user-friendly CLI feedback, including optional logging.</p> <p>Use cases: - Enforcing structure of external plugins before loading. - Automating validation in GitHub Actions or other CI tools. - Assuring consistency in modular libraries or educational tools.</p> Example <p>importspy ./examples/my_plugin.py -s ./contracts/expected.yml --log-level DEBUG</p> Note <p>Validation is powered by the core <code>Spy</code> class. Validation errors are caught and displayed with enhanced CLI formatting.</p>"},{"location":"api-reference/#importspy.cli.handle_validation_error","title":"<code>handle_validation_error(func)</code>","text":"<p>Decorator that formats validation errors for CLI output.</p> <p>Intercepts <code>ValueError</code> raised by the <code>Spy.importspy()</code> call and presents the error reason in a readable, styled terminal message.</p> <p>Used to wrap the main <code>importspy()</code> CLI command.</p>"},{"location":"api-reference/#importspy.cli.importspy","title":"<code>importspy(version=typer.Option(None, '--version', '-v', callback=(lambda value: show_version(value)), is_eager=True, help='Show the version and exit.'), modulepath=typer.Argument(str, help='Path to the Python module to load and validate.'), spymodel_path=typer.Option('spymodel.yml', '--spymodel', '-s', help='Path to the import contract file (.yml).'), log_level=typer.Option(None, '--log-level', '-l', help='Log level for output verbosity.'))</code>","text":"<p>Validates a Python module against a YAML-defined SpyModel contract.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>bool</code> <p>Show ImportSpy version and exit.</p> <code>Option(None, '--version', '-v', callback=lambda value: show_version(value), is_eager=True, help='Show the version and exit.')</code> <code>modulepath</code> <code>str</code> <p>Path to the Python module to validate.</p> <code>Argument(str, help='Path to the Python module to load and validate.')</code> <code>spymodel_path</code> <code>str</code> <p>Path to the YAML contract file. Defaults to <code>spymodel.yml</code>.</p> <code>Option('spymodel.yml', '--spymodel', '-s', help='Path to the import contract file (.yml).')</code> <code>log_level</code> <code>LogLevel</code> <p>Set logging verbosity (DEBUG, INFO, WARNING, ERROR).</p> <code>Option(None, '--log-level', '-l', help='Log level for output verbosity.')</code> <p>Returns:</p> Name Type Description <code>ModuleType</code> <code>ModuleType</code> <p>The validated Python module (if compliant).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the module does not conform to the contract.</p>"},{"location":"api-reference/#importspy.cli.main","title":"<code>main()</code>","text":"<p>CLI entry point.</p> <p>Executes the <code>importspy</code> Typer app, allowing CLI usage like:</p> <pre><code>$ importspy my_module.py -s my_contract.yml\n</code></pre>"},{"location":"api-reference/#importspy.cli.show_version","title":"<code>show_version(value)</code>","text":"<p>Displays the current version of ImportSpy and exits the process.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>If True, prints the version and exits immediately.</p> required"},{"location":"api-reference/#importspyconstants","title":"<code>importspy.constants</code>","text":""},{"location":"api-reference/#importspy.constants.Constants","title":"<code>Constants</code>","text":"<p>Canonical constants used by ImportSpy's runtime validation engine.</p> <p>This class acts as a reference for valid architectures, operating systems, Python interpreters, structural types, and annotation labels. All values defined here represent the allowed forms of metadata used to verify import contracts.</p> <p>Unlike <code>Config</code>, which reflects the current runtime, <code>Constants</code> provides the fixed set of values used for validation logic.</p>"},{"location":"api-reference/#importspy.constants.Constants.SupportedAnnotations","title":"<code>SupportedAnnotations</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported type annotations for validation purposes.</p>"},{"location":"api-reference/#importspy.constants.Constants.SupportedArchitectures","title":"<code>SupportedArchitectures</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid CPU architectures accepted in contracts.</p>"},{"location":"api-reference/#importspy.constants.Constants.SupportedClassAttributeTypes","title":"<code>SupportedClassAttributeTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Type of attribute in a class-level contract.</p>"},{"location":"api-reference/#importspy.constants.Constants.SupportedOS","title":"<code>SupportedOS</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid operating systems accepted in contracts.</p>"},{"location":"api-reference/#importspy.constants.Constants.SupportedPythonImplementations","title":"<code>SupportedPythonImplementations</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Valid Python interpreter implementations.</p>"},{"location":"api-reference/#importspy.constants.Contexts","title":"<code>Contexts</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Context types used for contract validation.</p> <p>These labels identify which layer of the system the error or constraint applies to.</p>"},{"location":"api-reference/#importspy.constants.Errors","title":"<code>Errors</code>","text":"<p>Reusable error string templates and labels.</p> <p>This utility provides consistent formatting for all error messages generated by ImportSpy. It supports singular and plural forms, as well as different validation categories: missing, mismatch, and invalid.</p>"},{"location":"api-reference/#importspy.constants.Errors.Category","title":"<code>Category</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Validation error types.</p>"},{"location":"api-reference/#importspyconfig","title":"<code>importspy.config</code>","text":"<p>importspy.config</p> <p>Static configuration definitions for ImportSpy.</p> <p>This module declares platform-wide constants used throughout ImportSpy for validating compatibility and structural expectations declared in SpyModel contracts. These values represent the officially supported CPU architectures, operating systems, Python interpreters, version targets, class attribute types, and accepted type annotations.</p>"},{"location":"api-reference/#importspy.config.Config","title":"<code>Config</code>","text":"<p>Static configuration container for ImportSpy validation.</p> <p>This class defines constants used during runtime and structural validation of Python modules. All values reflect supported targets or accepted types declared in <code>.yml</code> contracts interpreted by ImportSpy.</p> <p>Attributes:</p> Name Type Description <code>Architectures</code> <code>str</code> <p>Supported CPU architectures (e.g., \"x86_64\").</p> <code>Operating</code> <code>Systems (str</code> <p>Accepted OS identifiers (e.g., \"linux\").</p> <code>Python</code> <code>Versions (str</code> <p>Known compatible Python interpreter versions.</p> <code>Interpreters</code> <code>str</code> <p>Recognized Python implementation names.</p> <code>Attribute</code> <code>Types (str</code> <p>Whether class-level or instance-level variables.</p> <code>Annotation</code> <code>Types (str</code> <p>Type annotations allowed in contract validation.</p> <p>These constants are typically used in: - Runtime environment checks - Contract-based validation - Enforcement of developer-specified constraints</p>"},{"location":"api-reference/#importspylog_manager","title":"<code>importspy.log_manager</code>","text":"<p>importspy.log_manager</p> <p>Centralized logging system for ImportSpy.</p> <p>This module defines logging utilities that ensure consistent formatting, traceability, and developer-friendly output across both embedded and CLI modes. The <code>LogManager</code> provides a global configuration entry point for logging, while <code>CustomFormatter</code> enhances each message with context such as file name, line number, and function.</p> <p>Used in ImportSpy to provide high-fidelity logs during validation steps, contract resolution, and runtime introspection.</p>"},{"location":"api-reference/#importspy.log_manager.CustomFormatter","title":"<code>CustomFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Enhanced formatter for ImportSpy log messages.</p> <p>Adds contextual metadata (file, line, function) to each log entry, improving traceability across CLI execution and embedded imports.</p> Format <p>\"[timestamp] LEVEL logger name\" \"[caller: file, line, function] message\"</p> Example <p>2025-08-07 14:30:12 INFO importspy.module caller: loader.py, line: 42, function: validate_import Validation passed.</p>"},{"location":"api-reference/#importspy.log_manager.CustomFormatter.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the formatter with ImportSpy's extended log format.</p>"},{"location":"api-reference/#importspy.log_manager.CustomFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the log record with caller information.</p> <p>Adds custom attributes to the <code>LogRecord</code> for file name, line number, and function name.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted log message string.</p>"},{"location":"api-reference/#importspy.log_manager.LogManager","title":"<code>LogManager</code>","text":"<p>Centralized manager for logging configuration in ImportSpy.</p> <p>Ensures that all logs share a consistent format and output behavior, avoiding duplicate configuration across modules. Designed for both embedded validation flows and CLI analysis.</p> <p>Attributes:</p> Name Type Description <code>default_level</code> <code>int</code> <p>Default log level from the root logger.</p> <code>default_handler</code> <code>StreamHandler</code> <p>Stream handler with ImportSpy formatting.</p> <code>configured</code> <code>bool</code> <p>Whether the logger has already been initialized.</p>"},{"location":"api-reference/#importspy.log_manager.LogManager.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the default logging handler and formatter.</p>"},{"location":"api-reference/#importspy.log_manager.LogManager.configure","title":"<code>configure(level=None, handlers=None)</code>","text":"<p>Apply logging configuration globally.</p> <p>Should be called once per execution to avoid duplicated handlers. Adds provided handlers or defaults to the built-in stream handler.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level (e.g., logging.DEBUG). Defaults to current level.</p> <code>None</code> <code>handlers</code> <code>list[Handler]</code> <p>Custom logging handlers.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If configuration is attempted more than once.</p>"},{"location":"api-reference/#importspy.log_manager.LogManager.get_logger","title":"<code>get_logger(name)</code>","text":"<p>Return a named logger configured with ImportSpy's formatter.</p> <p>Ensures consistent behavior across all log invocations. If the logger does not yet have handlers, it assigns the default handler.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the logger (typically a module or subpackage name).</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: A logger instance ready for use.</p>"},{"location":"api-reference/#importspyutilitiesmodule_util","title":"<code>importspy.utilities.module_util</code>","text":"<p>Module utilities for runtime introspection and structure extraction.</p> <p>This module provides utility functions for analyzing Python modules dynamically, primarily to support ImportSpy's runtime validation mechanisms. It enables inspection of modules, their metadata, and internal structure at runtime.</p> <p>Features: - Inspect the call stack and determine caller modules. - Dynamically load and unload Python modules. - Extract version information via metadata or attributes. - Retrieve global variables, top-level functions, and class definitions. - Analyze methods, attributes (class-level and instance-level), and superclasses.</p> Example <pre><code>from importspy.utilities.module_util import ModuleUtil\nimport inspect\n\nmodule_util = ModuleUtil()\ninfo = module_util.get_info_module(inspect.stack()[0])\nprint(info.__name__)\n</code></pre>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil","title":"<code>ModuleUtil</code>","text":"<p>Provides methods to inspect and extract structural metadata from Python modules.</p> <p>This class enables runtime inspection of loaded modules for metadata such as functions, classes, variables, inheritance hierarchies, and version information. It is a core component used by ImportSpy to validate structural contracts.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.extract_annotation","title":"<code>extract_annotation(annotation)</code>","text":"<p>Convert a type annotation object into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>The annotation object to convert.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The extracted annotation string or None.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.extract_attributes","title":"<code>extract_attributes(cls_obj, info_module)</code>","text":"<p>Extract both class-level and instance-level attributes.</p> <p>Parameters:</p> Name Type Description Default <code>cls_obj</code> <code>Any</code> <p>The class to analyze.</p> required <code>info_module</code> <code>ModuleType</code> <p>The module containing the class.</p> required <p>Returns:</p> Type Description <code>List[AttributeInfo]</code> <p>List[AttributeInfo]: List of extracted attributes.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.extract_classes","title":"<code>extract_classes(info_module)</code>","text":"<p>Extract all class definitions from a module.</p> <p>Parameters:</p> Name Type Description Default <code>info_module</code> <code>ModuleType</code> <p>The module to inspect.</p> required <p>Returns:</p> Type Description <code>List[ClassInfo]</code> <p>List[ClassInfo]: Metadata about the module\u2019s classes.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.extract_functions","title":"<code>extract_functions(info_module)</code>","text":"<p>Extract all functions defined at the top level of the module.</p> <p>Parameters:</p> Name Type Description Default <code>info_module</code> <code>ModuleType</code> <p>The target module.</p> required <p>Returns:</p> Type Description <code>List[FunctionInfo]</code> <p>List[FunctionInfo]: Function metadata extracted from the module.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.extract_methods","title":"<code>extract_methods(cls_obj)</code>","text":"<p>Extract method definitions from a class object.</p> <p>Parameters:</p> Name Type Description Default <code>cls_obj</code> <code>Any</code> <p>The class to inspect.</p> required <p>Returns:</p> Type Description <code>List[FunctionInfo]</code> <p>List[FunctionInfo]: Extracted method metadata.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.extract_superclasses","title":"<code>extract_superclasses(cls)</code>","text":"<p>Extract base classes for a given class, recursively.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Any</code> <p>The class whose base classes are being extracted.</p> required <p>Returns:</p> Type Description <code>List[ClassInfo]</code> <p>List[ClassInfo]: Metadata for each superclass.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.extract_variables","title":"<code>extract_variables(info_module)</code>","text":"<p>Extract top-level variable definitions from a module.</p> <p>Parameters:</p> Name Type Description Default <code>info_module</code> <code>ModuleType</code> <p>The module to analyze.</p> required <p>Returns:</p> Type Description <code>List[VariableInfo]</code> <p>List[VariableInfo]: List of variable metadata.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.extract_version","title":"<code>extract_version(info_module)</code>","text":"<p>Attempt to retrieve the version string from a module.</p> <p>Parameters:</p> Name Type Description Default <code>info_module</code> <code>ModuleType</code> <p>The target module.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: Version string if found, otherwise None.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.get_info_module","title":"<code>get_info_module(caller_frame)</code>","text":"<p>Resolve a module object from a given caller frame.</p> <p>Parameters:</p> Name Type Description Default <code>caller_frame</code> <code>FrameInfo</code> <p>The caller frame to analyze.</p> required <p>Returns:</p> Type Description <code>ModuleType | None</code> <p>ModuleType | None: The resolved module or None if not found.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.inspect_module","title":"<code>inspect_module()</code>","text":"<p>Retrieve the current and caller frames from the stack.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple with the current and the outermost caller frame.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.load_module","title":"<code>load_module(info_module)</code>","text":"<p>Reload a module dynamically from its file location.</p> <p>Parameters:</p> Name Type Description Default <code>info_module</code> <code>ModuleType</code> <p>The module to reload.</p> required <p>Returns:</p> Type Description <code>ModuleType | None</code> <p>ModuleType | None: The reloaded module or None if loading fails.</p>"},{"location":"api-reference/#importspy.utilities.module_util.ModuleUtil.unload_module","title":"<code>unload_module(module)</code>","text":"<p>Unload a module from sys.modules and globals.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>ModuleType</code> <p>The module to unload.</p> required"},{"location":"api-reference/#importspyutilitiesruntime_util","title":"<code>importspy.utilities.runtime_util</code>","text":"<p>Runtime Environment Utilities</p> <p>Provides a lightweight utility for querying the system's hardware architecture.</p> <p>This module is used by ImportSpy to enforce architecture-specific constraints defined in import contracts (e.g., allowing a plugin only on x86_64 or arm64). It ensures that module imports are aligned with the intended deployment environment.</p>"},{"location":"api-reference/#importspy.utilities.runtime_util.RuntimeUtil","title":"<code>RuntimeUtil</code>","text":"<p>Utility class to inspect system architecture.</p> <p>This class provides methods to retrieve runtime hardware architecture details, which are essential when validating platform-specific import constraints in ImportSpy's embedded or CLI modes.</p>"},{"location":"api-reference/#importspy.utilities.runtime_util.RuntimeUtil.extract_arch","title":"<code>extract_arch()</code>","text":"<p>Return the name of the machine's hardware architecture.</p> <p>Uses <code>platform.machine()</code> to retrieve the architecture string, which may vary depending on the underlying system (e.g., \"x86_64\", \"arm64\", \"aarch64\"). This is typically used during contract validation to ensure that the importing environment matches expected deployment conditions.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The system's hardware architecture.</p> Example <p>RuntimeUtil().extract_arch()</p> <p>Output: 'arm64'</p>"},{"location":"api-reference/#importspyutilitiessystem_util","title":"<code>importspy.utilities.system_util</code>","text":"<p>System Utilities for ImportSpy</p> <p>Provides tools to inspect the host operating system and environment variables.</p> <p>This module supports ImportSpy by normalizing system-level information that may affect import contract validation. It helps ensure that environmental conditions are consistent and inspectable across different operating systems and deployment contexts.</p> Features <ul> <li>Detects the current operating system in a normalized, lowercase format.</li> <li>Retrieves all environment variables as a list of structured objects.</li> </ul> Example <p>from importspy.utilities.system_util import SystemUtil util = SystemUtil() util.extract_os() 'linux' envs = util.extract_envs() envs[0]</p> <p>Output: VariableInfo(name='PATH', annotation=None, value='/usr/bin')</p>"},{"location":"api-reference/#importspy.utilities.system_util.SystemUtil","title":"<code>SystemUtil</code>","text":"<p>Utility class for inspecting system-level properties.</p> <p>Used by ImportSpy to collect information about the current operating system and active environment variables. These details are typically validated against constraints defined in <code>.yml</code> import contracts.</p> <p>Methods:</p> Name Description <code>extract_os</code> <p>Return the normalized name of the current operating system.</p> <code>extract_envs</code> <p>Return all active environment variables as structured entries.</p>"},{"location":"api-reference/#importspy.utilities.system_util.SystemUtil.extract_envs","title":"<code>extract_envs()</code>","text":"<p>Return all environment variables as a list of structured objects.</p> <p>Collects all key-value pairs from <code>os.environ</code> and wraps them in <code>VariableInfo</code> namedtuples. The <code>annotation</code> field is reserved for optional type annotation metadata (currently set to <code>None</code>).</p> <p>Returns:</p> Type Description <code>List[VariableInfo]</code> <p>List[VariableInfo]: A list of environment variables available</p> <code>List[VariableInfo]</code> <p>in the current process environment.</p> Example <p>envs = SystemUtil().extract_envs() envs[0]</p> <p>Output: VariableInfo(name='PATH', annotation=None, value='/usr/bin')</p>"},{"location":"api-reference/#importspy.utilities.system_util.SystemUtil.extract_os","title":"<code>extract_os()</code>","text":"<p>Return the name of the operating system in lowercase format.</p> <p>This method uses <code>platform.system()</code> and normalizes the result to lowercase. It simplifies comparisons with import contract conditions that expect a canonical form such as \"linux\", \"darwin\", or \"windows\".</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The normalized operating system name (e.g., \"linux\", \"windows\").</p> Example <p>SystemUtil().extract_os()</p> <p>Output 'darwin'</p>"},{"location":"api-reference/#importspyutilitiespython_util","title":"<code>importspy.utilities.python_util</code>","text":"<p>Python Runtime Utilities</p> <p>Provides utility methods to inspect the active Python runtime environment, such as the version number and interpreter implementation.</p> <p>These utilities are useful within ImportSpy to evaluate whether the current runtime context satisfies declared compatibility constraints in import contracts. This includes checks for specific Python versions and interpreter families (CPython, PyPy, IronPython, etc.).</p> Example <p>from importspy.utilities.python_util import PythonUtil util = PythonUtil() util.extract_python_version()</p> <p>Output '3.12.0' util.extract_python_implementation() Output: 'CPython'</p>"},{"location":"api-reference/#importspy.utilities.python_util.PythonUtil","title":"<code>PythonUtil</code>","text":"<p>Utility class for inspecting Python runtime characteristics.</p> <p>Used internally by ImportSpy to validate runtime-specific conditions declared in <code>.yml</code> import contracts. This includes checking Python version and interpreter type during structural introspection and contract validation.</p>"},{"location":"api-reference/#importspy.utilities.python_util.PythonUtil.extract_python_implementation","title":"<code>extract_python_implementation()</code>","text":"<p>Return the implementation name of the running Python interpreter.</p> <p>Common values include \"CPython\", \"PyPy\", or \"IronPython\". This is essential in contexts where the implementation affects runtime behavior or compatibility with native extensions.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The interpreter implementation (e.g., \"CPython\").</p> Example <p>PythonUtil().extract_python_implementation()</p> <p>Output: 'CPython'</p>"},{"location":"api-reference/#importspy.utilities.python_util.PythonUtil.extract_python_version","title":"<code>extract_python_version()</code>","text":"<p>Return the currently active Python version as a string.</p> <p>This method queries the runtime using <code>platform.python_version()</code> and is typically used to match version constraints defined in an import contract.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Python version string (e.g., \"3.11.4\").</p> Example <p>PythonUtil().extract_python_version()</p> <p>Output: '3.11.4'</p>"},{"location":"advanced/spymodel/","title":"SpyModel Architecture","text":"<p>The SpyModel is the central object in ImportSpy's validation model. It represents both the structural definition of a Python module and the contextual constraints under which the module can be imported and executed.</p> <p>This hybrid role makes it a bridge between the static world of code structure and the dynamic world of runtime validation.</p>"},{"location":"advanced/spymodel/#overview","title":"Overview","text":"<p>ImportSpy introduces the concept of import contracts: structured <code>.yml</code> files that describe how a Python module is expected to behave, what it provides, and where it is valid.</p> <p>The SpyModel is the object-oriented representation of these contracts. It is composed of two main aspects:</p> <ul> <li>Structural metadata: variables, functions, classes, attributes, and type annotations</li> <li>Deployment constraints: supported architectures, operating systems, interpreters, Python versions, environment variables, and secrets</li> </ul> <p>This combination allows precise control over when and where a module can be imported.</p>"},{"location":"advanced/spymodel/#structural-layer","title":"Structural Layer","text":"<p>The structural part of a SpyModel describes the internal shape of the Python module:</p> <ul> <li>filename: the name of the <code>.py</code> file</li> <li>variables: global variables defined at module level, including optional type and value</li> <li>functions: standalone functions, with argument names, types, and return annotations</li> <li>classes: including attributes (class-level and instance-level), methods, and inheritance</li> </ul> <p>Each of these elements is validated against what the contract expects. This ensures that a module importing another can rely on a well-defined structure.</p>"},{"location":"advanced/spymodel/#deployment-layer","title":"Deployment Layer","text":"<p>The second part of the model defines where and under which conditions the module is considered valid.</p> <p>This is handled by the <code>deployments</code> field, a list of accepted runtime configurations. Each deployment includes:</p> <ul> <li>arch: CPU architecture (e.g., <code>x86_64</code>, <code>ARM</code>)</li> <li>systems: operating systems supported (<code>linux</code>, <code>windows</code>, <code>macos</code>)</li> <li>Each system includes:<ul> <li>environment:</li> <li>variables: required environment variables and their expected values</li> <li>secrets: variable names that must exist, without checking their value</li> <li>pythons: accepted Python interpreters and versions, each with:</li> <li>a list of expected modules, including their own structure</li> </ul> </li> </ul> <p>This allows defining highly specific constraints such as:</p> <ul> <li>\u201cThis plugin can only be used on Linux x86_64 with Python 3.12.9\u201d</li> <li>\u201cThis module requires <code>MY_SECRET_KEY</code> to be present in the environment\u201d</li> </ul>"},{"location":"advanced/spymodel/#schema-overview","title":"Schema Overview","text":"<p>The following UML diagram summarizes the structure of the SpyModel and its relationships:</p> <p></p> <p>Each node represents a data structure used during validation. The model is hierarchical: from deployments down to classes and attributes, every element is traceable and verifiable.</p>"},{"location":"advanced/spymodel/#design-rationale","title":"Design Rationale","text":"<p>The SpyModel is designed to be:</p> <ul> <li>Declarative: the contract is expressed in data, not code logic</li> <li>Versionable: stored as YAML, the contract can be committed to Git</li> <li>Composable: it supports multiple deployment targets and alternative environments</li> <li>Predictable: ensures that structural mismatches are detected early</li> </ul> <p>By separating structure from logic, ImportSpy enables a contract-driven development workflow. This is particularly useful in plugin frameworks, controlled environments, or distributed systems where consistency across modules and contexts is critical.</p> <p>ImportSpy treats contracts as first-class citizens. The SpyModel is the embodiment of this philosophy: a transparent, enforceable, and structured declaration of what a module requires and provides.</p>"},{"location":"advanced/violations/","title":"Violation System","text":"<p>The Violation System in ImportSpy is responsible for surfacing clear, contextual, and actionable errors when a Python module fails to comply with its declared import contract.</p> <p>Rather than raising generic Python exceptions, this subsystem transforms validation failures into precise, domain-specific diagnostics that are structured, explainable, and safe to expose in both development and production contexts.</p>"},{"location":"advanced/violations/#purpose","title":"Purpose","text":"<p>In modular and plugin-based systems, structural mismatches and runtime incompatibilities can lead to subtle bugs, hard crashes, or silent failures.</p> <p>The Violation System serves as a contract enforcement layer that:</p> <ul> <li>Captures detailed context about the failure (module, scope, variable, system)</li> <li>Distinguishes between missing, mismatched, and invalid values</li> <li>Produces human-readable error messages tailored to developers and CI pipelines</li> <li>Structures error reporting consistently across validation layers (module, runtime, environment, etc.)</li> </ul>"},{"location":"advanced/violations/#core-concepts","title":"Core Concepts","text":""},{"location":"advanced/violations/#1-contractviolation-interface","title":"1. <code>ContractViolation</code> Interface","text":"<p>An abstract base that defines the required interface for all contract violations. It ensures consistency across the different scopes (variables, functions, systems, etc.).</p> <pre><code>class ContractViolation(ABC):\n    @property\n    @abstractmethod\n    def context(self) -&gt; str\n\n    @abstractmethod\n    def label(self, spec: str) -&gt; str\n\n    @abstractmethod\n    def missing_error_handler(self, spec: str) -&gt; str\n\n    @abstractmethod\n    def mismatch_error_handler(self, spec: str) -&gt; str\n\n    @abstractmethod\n    def invalid_error_handler(self, spec: str) -&gt; str\n</code></pre>"},{"location":"advanced/violations/#2-basecontractviolation","title":"2. <code>BaseContractViolation</code>","text":"<p>A reusable abstract class that implements common logic for generating violation messages (e.g. missing values, mismatches, invalid values) across all scopes. It uses templates from <code>Errors</code> to construct consistent, high-fidelity diagnostics.</p> <pre><code>Example output:\n[Module Validation Error]: Variable 'API_KEY' is missing. - Declare it in the expected module.\n</code></pre>"},{"location":"advanced/violations/#specific-violation-classes","title":"Specific Violation Classes","text":"<p>Each domain (Variable, Function, Runtime, etc.) has its own implementation:</p> Class Purpose <code>VariableContractViolation</code> Handles variable mismatches or missing values <code>FunctionContractViolation</code> Detects function mismatches and signature issues <code>ModuleContractViolation</code> Validates filename and version consistency <code>RuntimeContractViolation</code> Validates system architectures (<code>x86_64</code>, <code>arm64</code>, etc.) <code>SystemContractViolation</code> Checks operating system and environment variable match <code>PythonContractViolation</code> Validates interpreter and Python version compatibility <p>Each one specializes the <code>.label()</code> method to return error-specific context (e.g., \"Environment variable <code>MY_SECRET</code> is missing in production runtime\").</p>"},{"location":"advanced/violations/#dynamic-payload-injection-via-bundle","title":"Dynamic Payload Injection via <code>Bundle</code>","text":"<p>Each violation operates with a shared mutable dictionary-like object called a <code>Bundle</code>:</p> <pre><code>@dataclass\nclass Bundle(MutableMapping):\n    state: Optional[dict[str, Any]] = field(default_factory=dict)\n</code></pre> <p>It serves two purposes:</p> <ul> <li>Collect contextual information at validation time (e.g., variable name, expected type)</li> <li>Dynamically populate templated error messages using the <code>Errors</code> constant map</li> </ul> <p>This design allows error messages to adapt to the specific failure, with no hardcoding.</p>"},{"location":"advanced/violations/#error-categorization","title":"Error Categorization","text":"<p>ImportSpy distinguishes between three primary error types:</p> Category Description <code>MISSING</code> A required entity (class, method, variable) was not found <code>MISMATCH</code> An entity exists but its value, annotation, or structure differs <code>INVALID</code> A value exists but does not belong to the allowed set (e.g., OS types) <p>The <code>Errors</code> constant defines templates for all categories, per context:</p> <pre><code>\"MISSING\":\n  \"module\":\n    \"template\": \"Expected module '{label}' is missing\"\n    \"solution\": \"Add the module to your import path\"\n</code></pre>"},{"location":"advanced/violations/#engineering-highlights","title":"Engineering Highlights","text":"<ul> <li>Encapsulation: All formatting, message construction, and error typing is abstracted out of validators.</li> <li>Separation of Concerns: Validators focus only on logic, while violations handle messaging.</li> <li>Templated Errors: All violations draw from <code>Errors</code>, ensuring uniformity and easier localization or branding.</li> <li>Composable Context: The <code>Bundle</code> allows rich diagnostics without tight coupling between layers.</li> </ul>"},{"location":"advanced/violations/#example-usage","title":"Example Usage","text":"<pre><code>from importspy.violation_systems import VariableContractViolation\n\nbundle = Bundle()\nbundle[\"expected_variable\"] = \"API_KEY\"\n\nraise ValueError(\n    VariableContractViolation(\n        scope=\"module\",\n        context=\"MODULE_CONTEXT\",\n        bundle=bundle\n    ).missing_error_handler(\"entity\")\n)\n</code></pre> <p>Produces:</p> <pre><code>[Module Validation]: Variable 'API_KEY' is missing - Declare it in the target module.\n</code></pre>"},{"location":"advanced/violations/#future-extensions","title":"Future Extensions","text":"<p>The Violation System is designed to be:</p> <ul> <li>Extensible with new scopes (<code>Decorators</code>, <code>ReturnTypes</code>, <code>Dependencies</code>)</li> <li>Pluggable with i18n/l10n systems</li> <li>Renderable in structured JSON for machine processing in DevOps pipelines</li> </ul>"},{"location":"advanced/violations/#summary","title":"Summary","text":"<p>The Violation System is not just error handling \u2014 it is ImportSpy\u2019s engine of clarity. It converts abstract contract mismatches into structured, interpretable diagnostics that empower developers to catch errors before runtime.</p> <p>By modeling validation feedback as first-class entities, ImportSpy enables precise governance across modular codebases.</p>"},{"location":"contracts/examples/","title":"Contract Examples","text":"<p>This page provides complete examples of import contracts (<code>.yml</code> files) supported by ImportSpy.</p> <p>Each example demonstrates how to declare structural expectations and runtime constraints for a Python module using the SpyModel format.</p>"},{"location":"contracts/examples/#basic-module-contract","title":"Basic Module Contract","text":"<p>This example defines a simple module called <code>plugin.py</code> with one variable, one class, and one method.</p> <pre><code>filename: plugin.py\nvariables:\n  - name: mode\n    value: production\n    annotation: str\nclasses:\n  - name: Plugin\n    methods:\n      - name: run\n        arguments:\n          - name: self\n        return_annotation: None\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.11\n            interpreter: CPython\n</code></pre>"},{"location":"contracts/examples/#function-with-typed-arguments","title":"Function With Typed Arguments","text":"<p>This contract describes a module where the <code>analyze</code> function requires two arguments with specific types.</p> <pre><code>filename: analyzer.py\nfunctions:\n  - name: analyze\n    arguments:\n      - name: self\n      - name: data\n        annotation: list[str]\n      - name: verbose\n        annotation: bool\n    return_annotation: dict\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.12\n            interpreter: CPython\n</code></pre>"},{"location":"contracts/examples/#class-with-attributes-and-methods","title":"Class With Attributes and Methods","text":"<p>This contract defines a module that exposes a <code>TaskManager</code> class with attributes and a method.</p> <pre><code>filename: manager.py\nclasses:\n  - name: TaskManager\n    attributes:\n      - name: tasks\n        annotation: list[str]\n      - name: state\n        annotation: str\n    methods:\n      - name: reset\n        arguments:\n          - name: self\n        return_annotation: None\ndeployments:\n  - arch: arm64\n    systems:\n      - os: darwin\n        environment:\n          variables:\n            - name: MODE\n              value: development\n              annotation: str\n        pythons:\n          - version: 3.11\n            interpreter: CPython\n</code></pre>"},{"location":"contracts/examples/#runtime-only-validation","title":"Runtime-Only Validation","text":"<p>This contract enforces only environmental and interpreter constraints \u2014 no structural validation.</p> <pre><code>deployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.10\n            interpreter: CPython\n</code></pre>"},{"location":"contracts/examples/#multiple-deployments","title":"Multiple Deployments","text":"<p>If your module supports multiple platforms, you can define multiple <code>deployments</code>.</p> <pre><code>filename: plugin.py\nclasses:\n  - name: Plugin\n    methods:\n      - name: run\n        arguments:\n          - name: self\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.11\n            interpreter: CPython\n  - arch: arm64\n    systems:\n      - os: darwin\n        pythons:\n          - version: 3.12\n            interpreter: CPython\n</code></pre>"},{"location":"contracts/examples/#using-environment-variables","title":"Using Environment Variables","text":"<p>This example enforces that an environment variable is set and has a given type.</p> <pre><code>filename: checker.py\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        environment:\n          variables:\n            - name: DEBUG\n              value: \"true\"\n              annotation: str\n        pythons:\n          - version: 3.10\n            interpreter: CPython\n</code></pre>"},{"location":"contracts/examples/#related-topics","title":"Related Topics","text":"<ul> <li>Contract Syntax</li> <li>Violation System</li> <li>SpyModel Architecture</li> </ul>"},{"location":"contracts/syntax/","title":"Contract Syntax","text":"<p>ImportSpy contracts are written in YAML and describe the structure and runtime expectations of a Python module. These contracts can be embedded or validated externally (e.g., in CI/CD), and act as import-time filters for enforcing compatibility and intent.</p> <p>A contract defines: - What variables, classes, and functions a module must expose - What runtime conditions are required (OS, architecture, Python version, etc.) - How strict or flexible the structure must be</p> <p>This document explains the full syntax supported in <code>.yml</code> contract files.</p>"},{"location":"contracts/syntax/#top-level-structure","title":"Top-Level Structure","text":"<p>Every <code>.yml</code> contract is structured as follows:</p> <pre><code>filename: plugin.py\nversion: \"1.2.3\"\n\nvariables:\n  - name: MODE\n    value: production\n    annotation: str\n\nfunctions:\n  - name: initialize\n    arguments:\n      - name: self\n      - name: config\n        annotation: dict\n    return_annotation: None\n\nclasses:\n  - name: Plugin\n    attributes:\n      - name: settings\n        value: default\n        annotation: dict\n        type: instance\n    methods:\n      - name: run\n        arguments:\n          - name: self\n        return_annotation: None\n    superclasses:\n      - BasePlugin\n\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        environment:\n          variables:\n            - name: IMPORTSPY_ENABLED\n              value: true\n              annotation: bool\n        pythons:\n          - version: \"3.11\"\n            interpreter: CPython\n            modules:\n              - filename: plugin.py\n                version: \"1.2.3\"\n</code></pre>"},{"location":"contracts/syntax/#fields-explained","title":"Fields Explained","text":""},{"location":"contracts/syntax/#filename","title":"<code>filename</code>","text":"<p>The name of the target Python file or module this contract applies to.</p>"},{"location":"contracts/syntax/#version","title":"<code>version</code>","text":"<p>Optional string that defines the expected version of the module. Can be used to pin specific builds or releases.</p>"},{"location":"contracts/syntax/#variables","title":"<code>variables</code>","text":"<p>Declares global or module-level variables the importer must provide.</p> <pre><code>variables:\n  - name: DEBUG\n    value: true\n    annotation: bool\n</code></pre> <p>Each variable entry supports: - <code>name</code> (required): Variable name - <code>value</code> (optional): Expected value - <code>annotation</code> (optional): Expected type annotation as string (e.g., <code>\"str\"</code>, <code>\"dict\"</code>)</p>"},{"location":"contracts/syntax/#functions","title":"<code>functions</code>","text":"<p>Specifies required functions in the importing module.</p> <pre><code>functions:\n  - name: load_config\n    arguments:\n      - name: path\n        annotation: str\n    return_annotation: dict\n</code></pre> <p>Each function supports: - <code>name</code>: The function's name - <code>arguments</code>: List of required arguments (each with optional <code>annotation</code>) - <code>return_annotation</code>: Expected return type (as string)</p>"},{"location":"contracts/syntax/#classes","title":"<code>classes</code>","text":"<p>Defines required class structures.</p> <pre><code>classes:\n  - name: Plugin\n    attributes:\n      - name: config\n        annotation: dict\n        value: {}\n        type: instance\n    methods:\n      - name: execute\n        arguments:\n          - name: self\n    superclasses:\n      - BasePlugin\n</code></pre> <p>A class may include: - <code>name</code>: Class name - <code>attributes</code>: A list of attributes exposed by the class   - <code>type</code>: Can be <code>\"instance\"</code> or <code>\"class\"</code> to indicate attribute level - <code>methods</code>: Required method declarations (same format as top-level <code>functions</code>) - <code>superclasses</code>: Optional list of superclass names expected</p> <p>Attributes are matched on name, annotation, and (if provided) value.</p>"},{"location":"contracts/syntax/#deployments","title":"<code>deployments</code>","text":"<p>This section defines runtime constraints in which the import is valid. It allows validation based on:</p> <ul> <li>Architecture</li> <li>Operating system</li> <li>Environment variables</li> <li>Python version and interpreter</li> <li>Declared modules</li> </ul> <pre><code>deployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        environment:\n          variables:\n            - name: MODE\n              value: prod\n              annotation: str\n        pythons:\n          - version: \"3.10\"\n            interpreter: CPython\n            modules:\n              - filename: plugin.py\n</code></pre>"},{"location":"contracts/syntax/#deployment-fields","title":"Deployment fields:","text":"Field Description <code>arch</code> CPU architecture (e.g. <code>x86_64</code>, <code>arm64</code>) <code>systems.os</code> Operating system (e.g. <code>linux</code>, <code>windows</code>) <code>environment.variables</code> Required runtime env variables <code>pythons.version</code> Required Python version (string) <code>pythons.interpreter</code> Interpreter (e.g., <code>CPython</code>) <code>modules</code> Specific modules to check (with filename/version) <p>Note: all conditions are AND-combined within a deployment block.</p>"},{"location":"contracts/syntax/#matching-rules","title":"Matching Rules","text":"<p>ImportSpy uses a strict structural validator. Here are some notes:</p> <ul> <li>Variables, functions, and methods are matched by name.</li> <li>Annotations are matched as plain strings \u2013 no semantic typing or runtime evaluation.</li> <li>If an annotation is omitted, it is not enforced.</li> <li>Superclasses are checked only by name, not by inheritance tree resolution.</li> </ul>"},{"location":"contracts/syntax/#best-practices","title":"Best Practices","text":"<ul> <li>Use consistent annotations: <code>\"str\"</code>, <code>\"dict\"</code>, <code>\"list\"</code>, etc.</li> <li>Prefer matching exact function signatures for critical plugins</li> <li>Define environment constraints only when needed (e.g., <code>IMPORTSPY_MODE=prod</code>)</li> <li>Use <code>modules.filename</code> to enforce versioning in multi-plugin systems</li> </ul>"},{"location":"contracts/syntax/#related-sections","title":"Related Sections","text":"<ul> <li>Contract Examples</li> <li>SpyModel Architecture</li> <li>Contract Violations</li> </ul>"},{"location":"errors/contract-violations/","title":"Contract Violations","text":"<p>When an import contract is not satisfied, ImportSpy blocks the import and raises a detailed error message. These violations are central to the library's purpose: enforcing predictable, secure, and valid module usage across Python runtimes.</p>"},{"location":"errors/contract-violations/#how-violations-work","title":"How Violations Work","text":"<p>Every time a module is imported using ImportSpy (either in embedded or CLI mode), the system performs deep introspection and validation checks.</p> <p>If something does not match the declared contract (<code>.yml</code>), ImportSpy will:</p> <ol> <li>Capture the context (e.g., <code>MODULE</code>, <code>CLASS</code>, <code>RUNTIME</code>, etc.)</li> <li>Identify the type of error:</li> <li><code>missing</code>: required element is absent</li> <li><code>mismatch</code>: expected vs actual values differ</li> <li><code>invalid</code>: unexpected or disallowed value found</li> <li>Generate a structured error message including:</li> <li>a human-readable message</li> <li>exact label of the failing entity</li> <li>possible solutions or corrective actions</li> </ol> <p>These violations are raised as <code>ValueError</code>, but contain detailed introspection metadata under the hood.</p>"},{"location":"errors/contract-violations/#error-categories","title":"Error Categories","text":"<p>ImportSpy organizes violations into logical layers, based on what is being validated:</p> Layer Validator Class Violation Raised Architecture/OS <code>RuntimeValidator</code> <code>RuntimeContractViolation</code> OS / Environment <code>SystemValidator</code> <code>SystemContractViolation</code> Python Interpreter <code>PythonValidator</code> <code>PythonContractViolation</code> Module File <code>ModuleValidator</code> <code>ModuleContractViolation</code> Class Structure <code>ClassValidator</code> <code>ModuleContractViolation (CLASS_CONTEXT)</code> Functions <code>FunctionValidator</code> <code>FunctionContractViolation</code> Variables / Args <code>VariableValidator</code> <code>VariableContractViolation</code> <p>Each of these violations inherits from <code>BaseContractViolation</code>, which provides: - A consistent interface for labeling (<code>.label()</code>) - Templated messages for each category - A <code>Bundle</code> object used to inject dynamic context into the error</p>"},{"location":"errors/contract-violations/#error-message-anatomy","title":"Error Message Anatomy","text":"<p>A full ImportSpy violation message looks like this:</p> <pre><code>[MODULE] Expected variable `timeout: int` not found in `my_module.py`\n\u2192 Please add the variable or update your contract.\n</code></pre> <p>Each message consists of: - <code>[CONTEXT]</code>: tells where the error occurred - Label: dynamically generated from the contract structure - Expected/Actual: shown for mismatch/invalid errors - Solution: human-readable advice from the YAML spec</p>"},{"location":"errors/contract-violations/#debugging-tips","title":"Debugging Tips","text":"<ul> <li>Use <code>-l DEBUG</code> when invoking ImportSpy via CLI to see exact comparison steps.</li> <li>Violations are deterministic and reproducible. If one fails in CI, it will fail locally too.</li> <li>You can inspect the violation context by capturing the <code>ValueError</code> and logging its message.</li> </ul>"},{"location":"errors/contract-violations/#contract-violation-table","title":"\ud83d\udccb Contract Violation Table","text":"<p>Below is a comprehensive list of all possible error messages emitted by ImportSpy:</p> Category Context Error Message <code>missing</code> <code>runtime</code> The runtime <code>CPython 3.12</code> is declared but missing. Ensure it is properly defined and implemented. <code>environment</code> The environment variable <code>DEBUG</code> is declared but missing. Ensure it is properly defined and implemented. <code>module</code> The variable <code>plugin_name</code> in module <code>extension.py</code> is declared but missing. Ensure it is properly defined and implemented. <code>class</code> The method <code>run</code> in class <code>Plugin</code> is declared but missing. Ensure it is properly defined and implemented. <code>mismatch</code> <code>runtime</code> The runtime <code>CPython 3.12</code> does not match the expected value. Expected: <code>CPython 3.11</code>, Found: <code>CPython 3.12</code>. Check the value and update the contract or implementation accordingly. <code>environment</code> The environment variable <code>LOG_LEVEL</code> does not match the expected value. Expected: <code>'INFO'</code>, Found: <code>'DEBUG'</code>. Check the value and update the contract or implementation accordingly. <code>class</code> The class attribute <code>engine</code> in class <code>Extension</code> does not match the expected value. Expected: <code>'docker'</code>, Found: <code>'podman'</code>. Check the value and update the contract or implementation accordingly. <code>invalid</code> <code>class</code> The argument <code>msg</code> of method <code>send</code> has an invalid value. Allowed values: <code>[str, None]</code>, Found: <code>42</code>. Update the value to one of the allowed options."},{"location":"errors/contract-violations/#related-topics","title":"Related Topics","text":"<ul> <li>Contract Syntax</li> <li>Embedded Mode</li> <li>CLI Mode</li> <li>SpyModel Architecture</li> </ul>"},{"location":"intro/install/","title":"Installation","text":"<p>You can install ImportSpy directly from PyPI using <code>pip</code>.</p>"},{"location":"intro/install/#basic-installation","title":"Basic installation","text":"<pre><code>pip install importspy\n</code></pre> <p>This installs both the core runtime and the command-line interface (CLI), allowing you to use ImportSpy in both Embedded Mode and CLI Mode.</p>"},{"location":"intro/install/#minimum-requirements","title":"Minimum requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Supported operating systems:</li> <li>Linux</li> <li>macOS</li> <li>Windows</li> <li>Compatible with CPython and alternative interpreters (e.g. IronPython), if declared in the contract</li> </ul>"},{"location":"intro/install/#updating-importspy","title":"Updating ImportSpy","text":"<p>To upgrade to the latest version:</p> <pre><code>pip install --upgrade importspy\n</code></pre>"},{"location":"intro/install/#verify-installation","title":"Verify installation","text":"<p>To confirm that ImportSpy is correctly installed and the CLI is available:</p> <pre><code>importspy --help\n</code></pre> <p>You should see the full list of command-line options and usage instructions.</p>"},{"location":"intro/overview/","title":"What is ImportSpy?","text":"<p>ImportSpy is a Python library that brings context awareness to the most fragile point in the lifecycle of a module: its import.</p> <p>It lets developers declare explicit import contracts \u2014 versionable <code>.yml</code> files that describe under which conditions a module can be imported. These contracts are validated at runtime, ensuring that the importing environment (and optionally the importing module) matches the declared requirements.</p> <p>If the conditions are not satisfied, the import fails immediately, with a detailed and structured error message.</p>"},{"location":"intro/overview/#why-use-importspy","title":"Why use ImportSpy?","text":"<p>Python offers no built-in mechanism to control how and where a module can be imported. In modular systems, plugin frameworks, and regulated environments, this leads to:</p> <ul> <li>Unexpected runtime errors</li> <li>Hard-to-diagnose misconfigurations</li> <li>Fragile CI/CD workflows</li> </ul> <p>ImportSpy solves this by introducing import-time validation based on:</p> <ul> <li>Runtime environment (OS, CPU, Python version, interpreter)</li> <li>Required environment variables and secret presence</li> <li>Structural expectations of the importing module (classes, methods, types\u2026)</li> </ul> <p>This results in safer, more predictable imports \u2014 whether you're building a plugin system, enforcing architectural rules, or protecting critical components.</p>"},{"location":"intro/overview/#how-does-it-work","title":"How does it work?","text":"<p>ImportSpy uses a declarative import contract \u2014 a <code>.yml</code> file written by the developer \u2014 to define expected conditions.</p> <p>At runtime, this contract is parsed into a structured Python object called a SpyModel, which is used internally for validation.</p> <p>Depending on the operation mode (Embedded or CLI), ImportSpy:</p> <ul> <li>Validates the runtime and system environment</li> <li>Optionally inspects the module that is importing the protected one</li> <li>Enforces declared constraints on structure, type annotations, variable values, and more</li> </ul> <p>If all constraints are respected, the import succeeds. If not, a descriptive error is raised (e.g. <code>ValueError</code>, <code>ImportSpyViolation</code>).</p>"},{"location":"intro/overview/#key-features","title":"Key features","text":"<ul> <li>\u2705 Declarative, versionable <code>.yml</code> import contracts</li> <li>\ud83e\udde0 Runtime validation of OS, CPU architecture, Python version/interpreter</li> <li>\ud83d\udd0d Structural checks on the importing module (classes, methods, attributes, types)</li> <li>\ud83d\udd10 Validation of required environment variables and secrets (presence only)</li> <li>\ud83d\ude80 Dual operation modes: Embedded Mode and CLI Mode</li> <li>\ud83e\uddea Full integration with CI/CD pipelines</li> <li>\ud83d\udccb Structured, human-readable error reports with actionable messages</li> </ul>"},{"location":"intro/overview/#who-is-it-for","title":"Who is it for?","text":"<p>ImportSpy is designed for:</p> <ul> <li>Plugin frameworks that enforce structural compliance</li> <li>Systems with strict version, runtime or security constraints</li> <li>Teams building modular Python applications</li> <li>Projects that need to validate import-time compatibility</li> <li>Open-source maintainers looking to define and enforce import boundaries</li> </ul>"},{"location":"intro/overview/#whats-next","title":"What\u2019s next?","text":"<ul> <li>\u2192 Install ImportSpy</li> <li>\u2192 Try a minimal working example</li> <li>\u2192 Learn about the operation modes</li> </ul>"},{"location":"intro/quickstart/","title":"Quickstart","text":"<p>This quickstart shows how to use ImportSpy in Embedded Mode to protect a Python module from being imported in an invalid context.</p>"},{"location":"intro/quickstart/#step-1-install-importspy","title":"Step 1 \u2014 Install ImportSpy","text":"<p>If you haven\u2019t already:</p> <pre><code>pip install importspy\n</code></pre>"},{"location":"intro/quickstart/#step-2-create-a-contract-spymodelyml","title":"Step 2 \u2014 Create a contract (<code>spymodel.yml</code>)","text":"<p>This file defines the conditions under which your module can be imported. For example, it can require specific Python versions, operating systems, or structure in the calling module.</p> <pre><code>filename: plugin.py\nclasses:\n  - name: Plugin\n    methods:\n      - name: run\n        arguments:\n          - name: self\n        return_annotation:\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.12\n            interpreter: CPython\n</code></pre> <p>Save this file as <code>spymodel.yml</code>.</p>"},{"location":"intro/quickstart/#step-3-protect-your-module","title":"Step 3 \u2014 Protect your module","text":"<p>Here\u2019s how to use ImportSpy inside the module you want to protect (e.g. <code>plugin.py</code>):</p> <pre><code># plugin.py\nfrom importspy import Spy\n\ncaller = Spy().importspy(filepath=\"spymodel.yml\")\n\n# Call something from the importer (for example)\ncaller.MyPlugin().run()\n</code></pre> <p>This checks the current environment and the module that is importing <code>plugin.py</code>. If it doesn\u2019t match the contract, ImportSpy raises an error and blocks the import.</p>"},{"location":"intro/quickstart/#step-4-create-an-importer","title":"Step 4 \u2014 Create an importer","text":"<p>Write a simple module that tries to import <code>plugin.py</code>.</p> <pre><code># main.py\nclass MyPlugin:\n    def run(self):\n        print(\"Plugin running\")\n\nimport plugin\n</code></pre>"},{"location":"intro/quickstart/#step-5-run-it","title":"Step 5 \u2014 Run it","text":"<p>If the environment and structure of <code>main.py</code> match the contract, the import will succeed:</p> <pre><code>python main.py\n</code></pre> <p>Otherwise, you'll get a clear and structured error like:</p> <pre><code>[Structure Violation] Missing required class 'Plugin' in caller module.\n</code></pre>"},{"location":"intro/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>Learn more about Embedded Mode</li> <li>Explore CLI Mode for validating modules from the outside</li> <li>Dive into contract syntax to write more advanced rules</li> </ul>"},{"location":"modes/cli/","title":"CLI Mode","text":"<p>ImportSpy can also be used outside of runtime to validate a Python module against a contract from the command line.</p> <p>This is useful in CI/CD pipelines, pre-commit hooks, or manual validations \u2014 whenever you want to enforce import contracts without modifying the target module.</p>"},{"location":"modes/cli/#how-it-works","title":"How it works","text":"<p>In CLI Mode, you invoke the <code>importspy</code> command and provide:</p> <ul> <li>The path to the module to validate</li> <li>The path to the YAML contract</li> <li>(Optional) a log level for output verbosity</li> </ul> <p>ImportSpy loads the module dynamically, builds its SpyModel, and compares it against the <code>.yml</code> contract.</p> <p>If the module is non-compliant, the command will:</p> <ul> <li>Exit with a non-zero status</li> <li>Print a structured error explaining the violation</li> </ul>"},{"location":"modes/cli/#basic-usage","title":"Basic usage","text":"<pre><code>importspy extensions.py -s spymodel.yml -l WARNING\n</code></pre>"},{"location":"modes/cli/#cli-options","title":"CLI options","text":"<pre><code>$ importspy --help\nUsage: importspy [OPTIONS] [MODULEPATH]\n\nValidates a Python module against a YAML-defined SpyModel contract.\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502   modulepath      [MODULEPATH]  Path to the Python module to load and validate.                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --version             -v                                  Show the version and exit.                              \u2502\n\u2502 --spymodel            -s      TEXT                        Path to the import contract file (.yml).                \u2502\n\u2502                                                           [default: spymodel.yml]                                 \u2502\n\u2502 --log-level           -l      [DEBUG|INFO|WARNING|ERROR]  Log level for output verbosity. [default: None]         \u2502\n\u2502 --install-completion                                      Install completion for the current shell.               \u2502\n\u2502 --show-completion                                         Show completion for the current shell, to copy it or    \u2502\n\u2502                                                           customize the installation.                             \u2502\n\u2502 --help                                                    Show this message and exit.                             |\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"modes/cli/#example-project","title":"Example project","text":"<p>Let\u2019s look at a full CLI-mode validation example.</p>"},{"location":"modes/cli/#project-structure","title":"Project structure","text":"<pre><code>pipeline_validation/\n\u251c\u2500\u2500 extensions.py\n\u2514\u2500\u2500 spymodel.yml\n</code></pre>"},{"location":"modes/cli/#source-files","title":"\ud83d\udcc4 Source files","text":"extensions.py <pre><code>from plugin_interface import Plugin\n\nauthor = \"Luca Atella\"\n\nplugin_name = \"plugin name\"\nplugin_description = \"plugin description\"\n\nengine = \"docker\"\n\nclass Extension(Plugin):\n\n    extension_name = \"extension_value\"\n\n    def __init__(self) -&gt; None:\n        self.extension_instance_name = \"extension_instance_value\"\n\n    def add_extension(self, msg:str) -&gt; str:\n        print(msg)\n        return \"Extension has added\"\n\n    def remove_extension(self):\n        print(\"Extension has removed\")\n\n    def http_get_request(self):\n        print(\"done\")\n\nclass Foo:\n\n    def get_bar(self):\n        print(\"Foobar\")\n</code></pre> spymodel.yml <pre><code>filename: extension.py\nvariables:\n  - name: engine\n    value: docker\n  - name: plugin_name\n    value: plugin name\n  - name: plugin_description\n    value: plugin description\nclasses:\n  - name: Extension\n    attributes:\n      - type: instance\n        name: extension_instance_name\n        value: extension_instance_value\n      - type: class\n        name: extension_name\n        value: extension_value\n    methods:\n      - name: __init__\n        arguments:\n          - name: self\n        return_annotation:\n      - name: add_extension\n        arguments:\n          - name: self\n          - name: msg\n            annotation: str\n        return_annotation: str\n      - name: remove_extension\n        arguments:\n          - name: self\n        return_annotation:\n      - name: http_get_request\n        arguments:\n          - name: self\n    superclasses:\n      - name: Plugin\n  - name: Foo\n    attributes:\n    methods:\n      - name: get_bar\n        arguments:\n          - name: self\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.12.9\n            interpreter: CPython\n            modules:\n              - filename: extension.py\n                version:\n                variables:\n                  - name: author \n                    value: Luca Atella\n                functions:\n                classes:\n          - version: 3.12.4\n            interpreter:\n            modules:\n              - filename: addons.py\n          - interpreter: IronPython\n            modules:\n              - filename: addons.py\n      - os: windows\n        pythons:\n          - version: 3.12.9\n            interpreter: CPython\n            modules:\n              - filename: extension.py\n                version:\n                variables:\n                  - name: author\n                    value: Luca Atella\n\n</code></pre>"},{"location":"modes/cli/#run-validation","title":"\ud83d\udd0d Run validation","text":"<pre><code>cd examples/plugin_based_architecture/pipeline_validation\nimportspy extensions.py -s spymodel.yml -l WARNING\n</code></pre> <p>If the module matches the contract, the command exits silently with <code>0</code>. If it doesn't, you\u2019ll see a structured error like:</p> <pre><code>[Structure Violation] Missing required method 'get_bar' in class 'Foo'.\n</code></pre>"},{"location":"modes/cli/#when-to-use-cli-mode","title":"When to use CLI Mode","text":"<p>Use CLI Mode for automation</p> <p>CLI Mode is ideal when you want to:</p> <ul> <li>Validate modules without changing their code</li> <li>Integrate checks in CI/CD pipelines</li> <li>Enforce contracts in external packages</li> <li>Run batch validations over multiple files</li> </ul>"},{"location":"modes/cli/#import-contract-syntax","title":"Import Contract Syntax","text":"<p>An ImportSpy contract is a YAML file that describes:</p> <ul> <li>The structure expected in the calling module (classes, methods, variables\u2026)</li> <li>The runtime and system environment where the module is allowed to run</li> <li>The required environment variables and optional secrets</li> </ul> <p>This contract is parsed into a <code>SpyModel</code>, which is then compared against the actual runtime and importing module.</p>"},{"location":"modes/cli/#overview","title":"\u2705 Overview","text":"<p>Here\u2019s a minimal but complete contract:</p> <pre><code>filename: extension.py\nvariables:\n  - name: engine\n    value: docker\nclasses:\n  - name: Plugin\n    methods:\n      - name: run\n        arguments:\n          - name: self\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.12\n            interpreter: CPython\n</code></pre>"},{"location":"modes/cli/#filename","title":"\ud83d\udcc4 filename","text":"<pre><code>filename: extension.py\n</code></pre> <ul> <li>Optional.</li> <li>Declares the filename of the module being validated.</li> <li>Used for reference and filtering in multi-module declarations.</li> </ul>"},{"location":"modes/cli/#variables","title":"\ud83d\udd23 variables","text":"<pre><code>variables:\n  - name: engine\n    value: docker\n</code></pre> <ul> <li>Declares top-level variables that must be present in the importing module.</li> <li>Supports optional <code>annotation</code> (type hint).</li> </ul> <pre><code>  - name: debug\n    annotation: bool\n    value: true\n</code></pre>"},{"location":"modes/cli/#functions","title":"\ud83e\udde0 functions","text":"<pre><code>functions:\n  - name: run\n    arguments:\n      - name: self\n      - name: config\n        annotation: dict\n    return_annotation: bool\n</code></pre> <ul> <li>Declares standalone functions expected in the importing module.</li> <li>Use <code>arguments</code> and <code>return_annotation</code> for stricter typing.</li> </ul>"},{"location":"modes/cli/#classes","title":"\ud83e\uddf1 classes","text":"<pre><code>classes:\n  - name: Plugin\n    attributes:\n      - type: class\n        name: plugin_name\n        value: my_plugin\n    methods:\n      - name: run\n        arguments:\n          - name: self\n    superclasses:\n      - name: BasePlugin\n</code></pre> <p>Each class can declare:</p> <ul> <li><code>attributes</code>: divided by <code>type</code> (<code>class</code> or <code>instance</code>)</li> <li><code>methods</code>: each with <code>arguments</code> and optional <code>return_annotation</code></li> <li><code>superclasses</code>: flat list of required superclass names</li> </ul>"},{"location":"modes/cli/#deployments","title":"\ud83e\udded deployments","text":"<p>This section defines where the module is allowed to run.</p> <pre><code>deployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.12.9\n            interpreter: CPython\n            modules:\n              - filename: extension.py\n                version: 1.0.0\n                variables:\n                  - name: author\n                    value: Luca Atella\n</code></pre>"},{"location":"modes/cli/#fields","title":"\u2733\ufe0f Fields","text":"Field Type Description <code>arch</code> Enum e.g. <code>x86_64</code>, <code>arm64</code> <code>os</code> Enum <code>linux</code>, <code>windows</code>, <code>darwin</code> <code>version</code> str Python version string (<code>3.12.4</code>) <code>interpreter</code> Enum <code>CPython</code>, <code>PyPy</code>, <code>IronPython</code>, etc. <code>modules</code> list Repeats the structure declaration per module <p>This structure allows fine-grained targeting of supported environments.</p>"},{"location":"modes/cli/#environment","title":"\ud83c\udf31 environment","text":"<p>Environment variables and secrets expected on the system.</p> <pre><code>environment:\n  variables:\n    - name: LOG_LEVEL\n      value: INFO\n    - name: DEBUG\n      annotation: bool\n      value: true\n  secrets:\n    - MY_SECRET_KEY\n    - DATABASE_PASSWORD\n</code></pre> <ul> <li><code>variables</code>: can define name, value, and annotation</li> <li><code>secrets</code>: only their presence is verified \u2014 values are never exposed</li> </ul>"},{"location":"modes/cli/#notes","title":"Notes","text":"<ul> <li>All fields are optional \u2014 contracts can be partial</li> <li>Field order does not matter</li> <li>Unknown fields are ignored with a warning (not an error)</li> </ul>"},{"location":"modes/cli/#learn-more","title":"Learn more","text":"<ul> <li>Contract syntax</li> <li>Contract violations</li> </ul>"},{"location":"modes/embedded/","title":"Embedded Mode","text":"<p>In Embedded Mode, ImportSpy is embedded directly into the module you want to protect. When that module is imported, it inspects the runtime environment and the importing module. If the context doesn't match the declared contract, the import fails with a structured error.</p>"},{"location":"modes/embedded/#how-it-works","title":"How it works","text":"<p>By using <code>Spy().importspy(...)</code>, a protected module can validate:</p> <ul> <li>The runtime (OS, Python version, architecture\u2026)</li> <li>The caller module\u2019s structure (classes, methods, variables, annotations\u2026)</li> </ul> <p>If validation passes, the module returns a reference to the caller. If not, the import is blocked and an exception is raised (e.g. <code>ValueError</code> or custom error class).</p>"},{"location":"modes/embedded/#real-world-example-plugin-based-architecture","title":"Real-world example: plugin-based architecture","text":"<p>Let\u2019s walk through a complete example. This simulates a plugin framework that wants to validate the structure of external plugins at import time.</p>"},{"location":"modes/embedded/#project-structure","title":"Project structure","text":"<pre><code>external_module_compliance/\n\u251c\u2500\u2500 extensions.py          # The plugin (caller)\n\u251c\u2500\u2500 package.py             # The protected framework\n\u251c\u2500\u2500 plugin_interface.py    # Base interface for plugins\n\u2514\u2500\u2500 spymodel.yml           # The import contract\n</code></pre>"},{"location":"modes/embedded/#source-files","title":"\ud83e\udde9 Source files","text":"package.py <pre><code>from importspy import (\n    Spy\n)\n\nimport logging\n\n__version__ = None\n\ncaller_module = Spy().importspy(filepath=\"./spymodel.yml\", log_level=logging.WARN)\ncaller_module.Foo().get_bar()\n</code></pre> extensions.py <pre><code>import package\nfrom plugin_interface import Plugin\n\nauthor = \"Luca Atella\"\n\nplugin_name = \"plugin name\"\nplugin_description = \"plugin description\"\n\nengine = \"docker\"\n\nclass Extension(Plugin):\n\n    extension_name = \"extension_value\"\n\n    def __init__(self) -&gt; None:\n        self.extension_instance_name = \"extension_instance_value\"\n\n    def add_extension(self, msg:str) -&gt; str:\n        print(msg)\n        return \"Extension has added\"\n\n    def remove_extension(self):\n        print(\"Extension has removed\")\n\n    def http_get_request(self):\n        print(\"done\")\n\nclass Foo:\n\n    def get_bar(self):\n        print(\"Foobar\")\n</code></pre> spymodel.yml <pre><code>filename: extension.py\nvariables:\n  - name: engine\n    value: docker\n  - name: plugin_name\n    value: plugin name\n  - name: plugin_description\n    value: plugin description\nclasses:\n  - name: Extension\n    attributes:\n      - type: instance\n        name: extension_instance_name\n        value: extension_instance_value\n      - type: class\n        name: extension_name\n        value: extension_value\n    methods:\n      - name: __init__\n        arguments:\n          - name: self\n        return_annotation:\n      - name: add_extension\n        arguments:\n          - name: self\n          - name: msg\n            annotation: str\n        return_annotation: str\n      - name: remove_extension\n        arguments:\n          - name: self\n        return_annotation:\n      - name: http_get_request\n        arguments:\n          - name: self\n    superclasses:\n      - name: Plugin\n  - name: Foo\n    attributes:\n    methods:\n      - name: get_bar\n        arguments:\n          - name: self\ndeployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.12.9\n            interpreter: CPython\n            modules:\n              - filename: extension.py\n                version:\n                variables:\n                  - name: author \n                    value: Luca Atella\n                functions:\n                classes:\n          - version: 3.12.4\n            interpreter:\n            modules:\n              - filename: addons.py\n          - interpreter: IronPython\n            modules:\n              - filename: addons.py\n      - os: windows\n        pythons:\n          - version: 3.12.9\n            interpreter: CPython\n            modules:\n              - filename: extension.py\n                version:\n                variables:\n                  - name: author\n                    value: Luca Atella\n\n</code></pre>"},{"location":"modes/embedded/#when-to-use-embedded-mode","title":"When to use Embedded Mode","text":"<p>Use this mode when:</p> <ul> <li>You want to protect a module from being imported incorrectly</li> <li>You\u2019re building a plugin system and expect structural consistency from plugins</li> <li>You want to fail fast in invalid environments</li> <li>You need to enforce custom logic during <code>import</code> without modifying the caller</li> </ul>"},{"location":"modes/embedded/#learn-more","title":"Learn more","text":"<ul> <li>Contract syntax</li> <li>Contract violations</li> </ul>"},{"location":"use_cases/","title":"Use Cases","text":"<p>ImportSpy brings contract-based validation to dynamic Python environments, enabling control, predictability, and safety.</p> <p>Below are common scenarios where ImportSpy proves useful.</p>"},{"location":"use_cases/#embedded-mode-in-plugin-architectures","title":"Embedded Mode in Plugin Architectures","text":"<p>In plugin-based systems, a core module often exposes an interface or expected structure that plugins must follow.</p> <p>With ImportSpy embedded in the core, plugins are validated at import time to ensure they define the required classes, methods, variables, and environment conditions.</p> <p>This prevents silent failures or misconfigurations by enforcing structural and runtime constraints early.</p> <p>Example: Plugin Enforced at Import</p> <p><code>python</code></p> <p>See also Embedded Mode and Contract Syntax for YAML details.</p>"},{"location":"use_cases/#cli-validation-in-cicd-pipelines","title":"CLI Validation in CI/CD Pipelines","text":"<p>In DevOps workflows or during pre-release validation, ImportSpy can be executed from the command line to ensure a Python module conforms to its declared import contract.</p> <p>Typical use cases: - Automated deployment verification - Open-source plugin contributions - Validating extension points in modular codebases  </p> <p>Example: Validate via CLI</p> <p><code>bash importspy extensions.py -s spymodel.yml -l INFO</code></p> <p>See CLI Mode for full usage.</p>"},{"location":"use_cases/#restricting-import-access-by-runtime-context","title":"Restricting Import Access by Runtime Context","text":"<p>A module can refuse to be imported unless specific runtime conditions are met \u2014 such as CPU architecture, OS, Python version, or interpreter.</p> <p>This enables: - Targeted deployments (e.g., Linux-only, CPython-only) - Restriction to known-safe execution environments - Fail-fast behavior in unsupported contexts</p> <p>Contracts can define system constraints like:</p> <pre><code>deployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.12\n            interpreter: CPython\n</code></pre> <p>If the runtime doesn't match, import fails with a clear error message.</p>"},{"location":"use_cases/#contract-as-code-executable-documentation","title":"Contract-as-Code: Executable Documentation","text":"<p>ImportSpy contracts double as living specifications for module structure and environment assumptions.</p> <p>Rather than maintaining separate interface docs, a <code>.yml</code> contract acts as:</p> <ul> <li>\u2705 Interface specification  </li> <li>\u2705 Compatibility schema  </li> <li>\u2705 Runtime validator  </li> </ul> <p>This approach improves communication in: - Plugin-based systems - Collaborative teams sharing Python APIs - Educational or onboarding contexts  </p> <p>Example Contract Snippet</p> <p><code>yaml classes:   - name: Plugin     methods:       - name: run         arguments:           - name: self</code></p> <p>Any contributor can run <code>importspy</code> or trigger the embedded validation to ensure conformance.</p>"},{"location":"use_cases/#supporting-multiple-deployment-targets","title":"Supporting Multiple Deployment Targets","text":"<p>Modules may need to support more than one runtime environment (e.g., Linux and Windows, or Python 3.10+).</p> <p>ImportSpy contracts support listing multiple valid deployments, each with its own OS, interpreter, and version constraints.</p> <pre><code>deployments:\n  - arch: x86_64\n    systems:\n      - os: linux\n        pythons:\n          - version: 3.10\n      - os: windows\n        pythons:\n          - version: 3.11\n</code></pre> <p>This enables the same module to be validated across CI matrices or downstream consumers with differing setups.</p> <p>Together, these use cases show how ImportSpy bridges runtime context and modular structure through declarative contracts \u2014 empowering safer, more predictable Python architectures.</p>"}]}